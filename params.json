{"name":"evoMPS","tagline":"Quantum many-particle dynamics in 1D with matrix product states","body":"![evoMPS](https://dl.dropboxusercontent.com/u/12738669/evoMPS/evoMPSlogo_200.png)\r\n\r\n### Tutorial videos:\r\n\r\n* [Installation](http://vimeo.com/user19042101/evomps-tutorial-installation)\r\n* [Find ground state](http://vimeo.com/user19042101/evomps-tutorial-ground)\r\n* [Find excitations](http://vimeo.com/user19042101/evomps-tutorial-excitations)\r\n\r\nIntroduction\r\n------------\r\n\r\nevoMPS simulates time-evolution (real or imaginary) of one-dimensional \r\nmany-particle quantum systems using matrix product states\r\n(MPS) and the time dependent variational principle (TDVP).\r\n\r\nIt can be used to efficiently find ground states and simulate dynamics.\r\n\r\nThe evoMPS implementation assumes a nearest-neighbour or next-nearest-neighbour\r\nHamiltonian and one of the following situations:\r\n\r\n* states on a finite chain with open boundary conditions\r\n* spatially uniform states on an infinite chain\r\n* otherwise uniform states with a localized nonuniformity on an infinite chain (only nearest-neighbour at present)\r\n\r\nIt is based on algorithms published by: \r\n\r\n* Jutho Haegeman\r\n* J. Ignacio Cirac\r\n* Tobias J. Osborne\r\n* Iztok Pizorn\r\n* Henri Verschelde\r\n* Frank Verstraete\r\n\r\nand available on arxiv.org under [arXiv:1103.0936v2](http://arxiv.org/abs/1103.0936v2). \r\nThe algorithm for handling localized\r\nnonuniformities on infinite chains was developed by:\r\n\r\n* Ashley Milsted\r\n* Tobias J. Osborne\r\n* Frank Verstraete\r\n* Jutho Haegeman\r\n\r\nand is detailed in [arXiv:1207.0691](http://arxiv.org/abs/1207.0691).\r\nFor details, see doc/implementation_details.pdf and the source code itself,\r\nwhich I endeavour to annotate thoroughly.\r\n\r\nevoMPS is implemented in Python using Scipy <http://www.scipy.org> and\r\nbenefits from optimized linear algebra libraries being installed (BLAS and LAPACK).\r\nFor more details, see INSTALL.\r\n\r\nevoMPS was originally developed as part of an MSc project by Ashley Milsted,\r\nsupervised by Tobias Osborne at the Institute for Theoretical Physics of\r\nLeibniz Universität Hannover <http://www.itp.uni-hannover.de/>.\r\n\r\nUsage\r\n-----\r\n\r\nThe evoMPS algorithms are presented as python classes to be used in a script.\r\nSome example scripts can be found in the \"examples\" directory.\r\nTo run an example script without installing the evoMPS modules, copy it to the base \r\ndirectory first e.g. under Windows::\r\n    \r\n    copy examples\\transverse_ising_uniform.py .\r\n    python transverse_ising_uniform.py\r\n\r\nEssentially, the user defines a spin chain Hilbert space\r\nand a nearest-neighbour Hamiltonian and then carries out a series of small \r\ntime steps (numerically integrating the \"Schrödinger equation\" for the MPS parameters)::\r\n\r\n    sim = EvoMPS_TDVP_Uniform(bond_dim, local_hilb_dim, my_hamiltonian)\r\n    \r\n    for i in range(max_steps):\r\n        sim.update()\r\n        \r\n        my_exp_val = sim.expect_1s(my_op)\r\n        \r\n        sim.take_step_RK4(dtau)\r\n\r\nOperators, including the Hamiltonian, are defined as arrays like this::\r\n\r\n    pauli_z = numpy.array([[1, 0],\r\n                           [0, -1]])\r\n                     \r\nor as python callables (functions) like this::\r\n\r\n    def pauli_z(s, t):\r\n        if s == t:\r\n            return (-1.0)**s\r\n        else:\r\n            return 0\r\n\r\nCalculating expectation values or other quantities can be done after each step \r\nas desired.\r\n\r\nSwitching between imaginary time evolution (for finding the ground state)\r\nand real time evolution is as easy as multiplying the time step size by a factor of i!\r\n\r\n\r\nContact\r\n-------\r\n\r\nPlease send comments to:\r\n\r\nashmilsted at <google's well-known email service>\r\n\r\nTo submit ideas or bug reports, please use the GitHub Issues system <http://github.com/amilsted/evoMPS/>.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}